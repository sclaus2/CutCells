"""Emit CutCells-style C++ headers from normalized tables."""

from __future__ import annotations

from pathlib import Path
from typing import Dict, List, Optional

from .topology import num_edges

CELL_ENUM_LITERALS = [
    "cell::type::point",
    "cell::type::interval",
    "cell::type::triangle",
    "cell::type::tetrahedron",
    "cell::type::quadrilateral",
    "cell::type::hexahedron",
    "cell::type::prism",
    "cell::type::pyramid",
]


def _vtk_derived_notice_lines(
    vtk_ref: Optional[str] = None, vtk_header_path: Optional[str] = None
) -> List[str]:
    lines = [
        "// -----------------------------------------------------------------------------",
        "// This file is generated by CutCells tablegen.",
        "//",
        "// It contains case tables derived from VTK's vtkTableBasedClipCases.h",
        "// (Visualization Toolkit, TableBasedClip).",
        "//",
        f"// VTK ref: {vtk_ref}" if vtk_ref else "// VTK ref: (not recorded)",
        f"// VTK header path override: {vtk_header_path}"
        if vtk_header_path
        else "// VTK header path override: (none)",
        "//",
        "// VTK is licensed under the BSD 3-Clause License.",
        "// See third_party/VTK-Copyright.txt in this repository.",
        "// -----------------------------------------------------------------------------",
    ]
    return lines


def _brace_join(rows: List[str]) -> str:
    return "{ " + ", ".join(rows) + " }"


def _format_int_list(values: List[int]) -> str:
    return _brace_join([str(v) for v in values])


def _format_cell_type_list(values: List[int]) -> str:
    mapped = []
    for v in values:
        if v < 0 or v >= len(CELL_ENUM_LITERALS):
            raise ValueError(f"Cell type enum value {v} out of range")
        mapped.append(CELL_ENUM_LITERALS[v])
    return _brace_join(mapped)


def _format_matrix(matrix: List[List[int]]) -> str:
    inner = ["{ " + ", ".join(str(v) for v in row) + " }" for row in matrix]
    return "{\n" + ",\n".join(f"    {row}" for row in inner) + "\n}"


def _header_guard(cell_type: str, table_kind: str) -> str:
    return f"CUT_CELLS_{cell_type.upper()}_{table_kind.upper()}_TABLES_H"


def emit_header(
    cell_type: str, table_kind: str, arrays: Dict[str, List], output_dir: Path
) -> Path:
    """Write a single header for one cell type + table kind (inside/outside/interface)."""
    output_dir.mkdir(parents=True, exist_ok=True)
    path = output_dir / f"cut_{cell_type}_{table_kind}_tables.h"

    n_cases = len(arrays["intersected_edges"])
    n_edges = num_edges(cell_type)
    guard = _header_guard(cell_type, table_kind)

    lines: List[str] = []
    lines.append(f"#ifndef {guard}")
    lines.append(f"#define {guard}")
    lines.append("")
    lines.append('#include "cell_types.h"')
    if cell_type == "quadrilateral" and table_kind == "inside":
        # For uint8_t / int8_t in ambiguity metadata
        lines.append("#include <cstdint>")
    if cell_type == "quadrilateral" and table_kind == "inside":
        # For uint8_t / int8_t in ambiguity metadata
        lines.append("#include <cstdint>")
    lines.append("")
    lines.append("namespace cutcells::cell::generated {")
    lines.append("")
    lines.append(
        f"constexpr int cut_{cell_type}_{table_kind}_intersected_edges[{n_cases}][{n_edges}] = "
        + _format_matrix(arrays["intersected_edges"])
        + ";"
    )
    lines.append("")
    lines.append(
        f"constexpr int cut_{cell_type}_{table_kind}_sub_element_offset[{n_cases + 1}] = "
        + _format_int_list(arrays["sub_element_offset"])
        + ";"
    )
    lines.append("")
    lines.append(
        f"constexpr cell::type cut_{cell_type}_{table_kind}_sub_element_cell_types[{len(arrays['sub_element_cell_types'])}] = "
        + _format_cell_type_list(arrays["sub_element_cell_types"])
        + ";"
    )
    lines.append("")
    lines.append(
        f"constexpr int cut_{cell_type}_{table_kind}_sub_element[{len(arrays['sub_element'])}] = "
        + _format_int_list(arrays["sub_element"])
        + ";"
    )

    extra_coords = arrays.get("extra_coords", [])
    if extra_coords:
        lines.append("")
        lines.append(
            f"constexpr double cut_{cell_type}_{table_kind}_extra_coords[{len(extra_coords)}] = "
            + _format_int_list(extra_coords)
            + ";"
        )

    lines.append("")
    lines.append("} // namespace cutcells::cell::generated")
    lines.append("")
    lines.append(f"#endif // {guard}")

    path.write_text("\n".join(lines))
    return path


def emit_all(
    cell_type: str, tables_by_kind: Dict[str, Dict[str, List]], output_dir: Path
) -> List[Path]:
    written: List[Path] = []
    for kind, arrays in tables_by_kind.items():
        written.append(emit_header(cell_type, kind, arrays, output_dir))
    return written


def _emit_tet_like_header(
    cell_type: str,
    table_kind: str,
    arrays: Dict[str, List],
    output_dir: Path,
    provenance: Optional[str] = None,
    vtk_ref: Optional[str] = None,
    vtk_header_path: Optional[str] = None,
) -> Path:
    """Write header in tetrahedron-like format with fixed-width 2D arrays."""
    output_dir.mkdir(parents=True, exist_ok=True)
    path = output_dir / f"cut_{cell_type}_{table_kind}_tables.h"

    # Copy lists so we can safely mutate for augmentation (e.g. quad ambiguity)
    arrays = {k: (v.copy() if isinstance(v, list) else v) for k, v in arrays.items()}

    n_cases = len(arrays["intersected_edges"])
    n_edges = num_edges(cell_type)
    guard = _header_guard(cell_type, table_kind)

    # Convert VTK flat format to tet-like format
    # Extract subcells from flat stream
    subcells_data = _extract_subcells_from_flat(arrays)

    quad_amb_meta = None
    if cell_type == "quadrilateral":
        quad_amb_meta = _augment_quadrilateral_ambiguity(table_kind, arrays)
        # Re-extract after augmentation
        subcells_data = _extract_subcells_from_flat(arrays)

    lines: List[str] = []
    lines.append(f"#ifndef {guard}")
    lines.append(f"#define {guard}")
    lines.append("")

    if provenance == "vtk":
        lines.extend(
            _vtk_derived_notice_lines(vtk_ref=vtk_ref, vtk_header_path=vtk_header_path)
        )
        lines.append("")

    lines.append('#include "cell_types.h"')
    if cell_type == "quadrilateral" and table_kind == "inside":
        # For uint8_t / int8_t in ambiguity metadata
        lines.append("#include <cstdint>")
    lines.append("")
    lines.append(f"namespace cutcells::cell::{cell_type} {{")
    lines.append("")

    # Topology and intersected_edges only in the "inside" header to avoid redefinition
    if table_kind == "inside":
        # Topology (if quad/hex)
        if cell_type == "quadrilateral":
            lines.append("// Topology")
            lines.append("constexpr int edges[4][2] = {{0,1}, {1,2}, {2,3}, {3,0}};")
            lines.append("")
        elif cell_type == "hexahedron":
            lines.append("// Topology")
            lines.append("constexpr int edges[12][2] = {")
            lines.append("    {0,1}, {1,2}, {2,3}, {3,0},  // bottom face")
            lines.append("    {4,5}, {5,6}, {6,7}, {7,4},  // top face")
            lines.append(
                "    {0,4}, {1,5}, {3,7}, {2,6}   // vertical edges (VTK TableBasedClip ordering)"
            )
            lines.append("};")
            lines.append("")
            lines.append("constexpr int faces[6][4] = {")
            lines.append("    {0,3,2,1}, {4,5,6,7},  // bottom, top")
            lines.append("    {0,1,5,4}, {1,2,6,5},  // front, right")
            lines.append("    {2,3,7,6}, {3,0,4,7}   // back, left")
            lines.append("};")
            lines.append("")

        # Intersected edges
        lines.append(
            f"// Intersected edges per case (1 = intersected, 0 = not intersected)"
        )
        lines.append(
            f"constexpr int intersected_edges[{n_cases}][{n_edges}] = "
            + _format_matrix(arrays["intersected_edges"])
            + ";"
        )
        lines.append("")

        if cell_type == "quadrilateral" and quad_amb_meta is not None:
            # Ambiguity metadata used by runtime asymptotic-decider selection
            lines.append("// Ambiguity metadata (opposite-corner cases)")
            lines.append(
                f"constexpr uint8_t case_is_ambiguous_tbl[16] = "
                + _format_int_list(quad_amb_meta["case_is_ambiguous_tbl"])
                + ";"
            )
            lines.append(
                f"constexpr int8_t amb_case_id[16] = "
                + _format_int_list(quad_amb_meta["amb_case_id"])
                + ";"
            )
            lines.append("")

    # Number of subcells per case
    num_subcells_per_case = []
    for i in range(n_cases):
        start = arrays["sub_element_offset"][i]
        end = arrays["sub_element_offset"][i + 1]
        num_subcells_per_case.append(end - start)

    lines.append(f"// Number of subcells produced for each case ({table_kind} volume)")
    lines.append(
        f"constexpr int num_subcells_{table_kind}[{n_cases}] = "
        + _format_int_list(num_subcells_per_case)
        + ";"
    )
    lines.append("")

    # Offset into subcell array
    lines.append(f"// Offset into subcell array for each case")
    lines.append(
        f"constexpr int case_subcell_offset_{table_kind}[{n_cases + 1}] = "
        + _format_int_list(arrays["sub_element_offset"])
        + ";"
    )
    lines.append("")

    # Cell types
    total_subcells = len(arrays["sub_element_cell_types"])
    lines.append(f"// Cell types for {table_kind} subcells")
    lines.append(
        f"constexpr type subcell_type_{table_kind}[{total_subcells}] = "
        + _format_cell_type_list(arrays["sub_element_cell_types"])
        + ";"
    )
    lines.append("")

    # Subcell vertices (fixed-width 2D array with -1 padding)
    max_verts = subcells_data["max_verts_per_subcell"]
    padded_verts = subcells_data["padded_vertices"]

    lines.append(
        f"// Subcell vertices (max {max_verts} vertices per subcell, -1 padding)"
    )
    lines.append(
        f"// Tokens: <100 = edge id, 100..199 = 100+vertex_id, >=200 = 200+special_point_id"
    )
    lines.append(
        f"constexpr int subcell_verts_{table_kind}[{total_subcells}][{max_verts}] = "
        + _format_matrix(padded_verts)
        + ";"
    )

    # Special (derived) points, e.g. VTK centroid N0
    sp_count = arrays.get("special_point_count", [])
    sp_offset = arrays.get("special_point_offset", [])
    sp_data = arrays.get("special_point_data", [])
    if sp_count:
        lines.append("")
        lines.append("// Special points (e.g. centroid): per-case definition streams")
        lines.append(
            f"constexpr int special_point_count_{table_kind}[{len(sp_count)}] = "
            + _format_int_list(sp_count)
            + ";"
        )
        lines.append(
            f"constexpr int special_point_offset_{table_kind}[{len(sp_offset)}] = "
            + _format_int_list(sp_offset)
            + ";"
        )
        lines.append(
            f"constexpr int special_point_data_{table_kind}[{len(sp_data)}] = "
            + _format_int_list(sp_data)
            + ";"
        )

    if cell_type == "quadrilateral" and quad_amb_meta is not None:
        if table_kind == "inside":
            lines.append("")
            lines.append(
                "// Ambiguity override ranges: [begin0,end0,begin1,end1] per ambiguous case"
            )
            lines.append(
                f"constexpr int amb_range_inside[{len(quad_amb_meta['amb_range_inside'])}] = "
                + _format_int_list(quad_amb_meta["amb_range_inside"])
                + ";"
            )
        elif table_kind == "outside":
            lines.append("")
            lines.append(
                "// Ambiguity override ranges: [begin0,end0,begin1,end1] per ambiguous case"
            )
            lines.append(
                f"constexpr int amb_range_outside[{len(quad_amb_meta['amb_range_outside'])}] = "
                + _format_int_list(quad_amb_meta["amb_range_outside"])
                + ";"
            )
        elif table_kind == "interface":
            lines.append("")
            lines.append(
                "// Ambiguity override ranges: [begin0,end0,begin1,end1] per ambiguous case"
            )
            lines.append(
                f"constexpr int amb_range_interface[{len(quad_amb_meta['amb_range_interface'])}] = "
                + _format_int_list(quad_amb_meta["amb_range_interface"])
                + ";"
            )

    lines.append("")
    lines.append(f"}} // namespace cutcells::cell::{cell_type}")
    lines.append("")
    lines.append(f"#endif // {guard}")

    path.write_text("\n".join(lines))
    return path


def _append_triangle(arrays: Dict[str, List], tokens: List[int]) -> None:
    # arrays["sub_element_cell_types"] uses CutCells enum mapping (triangle=2)
    arrays["sub_element_cell_types"].append(2)
    arrays["sub_element"].append(len(tokens))
    arrays["sub_element"].extend(tokens)


def _append_quad(arrays: Dict[str, List], tokens: List[int]) -> None:
    # arrays["sub_element_cell_types"] uses CutCells enum mapping (quadrilateral=4)
    arrays["sub_element_cell_types"].append(4)
    arrays["sub_element"].append(len(tokens))
    arrays["sub_element"].extend(tokens)


def _augment_quadrilateral_ambiguity(
    table_kind: str, arrays: Dict[str, List]
) -> Dict[str, List] | None:
    """Augment quad tables with asymptotic-decider ambiguity variants.

    Variant 0: choose diagonal (0,2) connectivity
    Variant 1: choose diagonal (1,3) connectivity
    """
    amb_masks = [0b0101, 0b1010]
    n_amb = len(amb_masks)

    offsets = arrays["sub_element_offset"]
    total_before = len(arrays["sub_element_cell_types"])

    def case_range(mask: int) -> tuple[int, int]:
        return offsets[mask], offsets[mask + 1]

    # Metadata tables (only emitted once in inside header)
    case_is_ambiguous_tbl = [0] * 16
    amb_case_id = [-1] * 16
    for amb_id, m in enumerate(amb_masks):
        case_is_ambiguous_tbl[m] = 1
        amb_case_id[m] = amb_id

    meta: Dict[str, List] = {
        "case_is_ambiguous_tbl": case_is_ambiguous_tbl,
        "amb_case_id": amb_case_id,
        "amb_range_inside": [],
        "amb_range_outside": [],
        "amb_range_interface": [],
    }

    if table_kind == "interface":
        # No new subcells needed; both pairings already exist in base tables.
        v0_begin, v0_end = case_range(0b1010)  # edges (0,1) and (2,3)
        v1_begin, v1_end = case_range(0b0101)  # edges (0,3) and (1,2)
        for _ in amb_masks:
            meta["amb_range_interface"].extend([v0_begin, v0_end, v1_begin, v1_end])
        return meta

    if table_kind == "inside":
        # Append connected-region decompositions for both diagonals.
        # Connected diagonal (0,2): polygon (V0,E0,E1,V2,E2,E3) split into two quads.
        conn_02_begin = len(arrays["sub_element_cell_types"])
        _append_quad(arrays, [100, 0, 1, 102])
        _append_quad(arrays, [100, 102, 2, 3])
        conn_02_end = len(arrays["sub_element_cell_types"])

        # Connected diagonal (1,3): polygon (V1,E1,E2,V3,E3,E0) split into two quads.
        conn_13_begin = len(arrays["sub_element_cell_types"])
        _append_quad(arrays, [101, 1, 2, 103])
        _append_quad(arrays, [101, 103, 3, 0])
        conn_13_end = len(arrays["sub_element_cell_types"])

        base_05 = case_range(0b0101)
        base_10 = case_range(0b1010)

        # For mask 0101, inside vertices lie on diagonal (0,2)
        meta["amb_range_inside"].extend(
            [conn_02_begin, conn_02_end, base_05[0], base_05[1]]
        )
        # For mask 1010, inside vertices lie on diagonal (1,3)
        meta["amb_range_inside"].extend(
            [base_10[0], base_10[1], conn_13_begin, conn_13_end]
        )

        return meta

    if table_kind == "outside":
        # Append disconnected-region triangulations for both diagonals.
        # Disconnected diagonal (0,2): triangles at V0 and V2
        disc_02_begin = len(arrays["sub_element_cell_types"])
        for tri in ([100, 0, 3], [102, 1, 2]):
            _append_triangle(arrays, tri)
        disc_02_end = len(arrays["sub_element_cell_types"])

        # Disconnected diagonal (1,3): triangles at V1 and V3
        disc_13_begin = len(arrays["sub_element_cell_types"])
        for tri in ([101, 0, 1], [103, 2, 3]):
            _append_triangle(arrays, tri)
        disc_13_end = len(arrays["sub_element_cell_types"])

        base_05 = case_range(0b0101)
        base_10 = case_range(0b1010)

        # For mask 0101, outside vertices lie on diagonal (1,3)
        meta["amb_range_outside"].extend(
            [disc_13_begin, disc_13_end, base_05[0], base_05[1]]
        )
        # For mask 1010, outside vertices lie on diagonal (0,2)
        meta["amb_range_outside"].extend(
            [base_10[0], base_10[1], disc_02_begin, disc_02_end]
        )

        return meta

    return None


def _extract_subcells_from_flat(arrays: Dict[str, List]) -> Dict:
    """Extract subcell data from VTK flat format."""
    sub_element = arrays["sub_element"]
    num_subcells = len(arrays["sub_element_cell_types"])

    subcells = []
    idx = 0
    for _ in range(num_subcells):
        nverts = sub_element[idx]
        verts = sub_element[idx + 1 : idx + 1 + nverts]
        subcells.append(verts)
        idx += 1 + nverts

    # Find max vertices
    max_verts = max(len(v) for v in subcells) if subcells else 0

    # Pad with -1
    padded = []
    for verts in subcells:
        row = list(verts) + [-1] * (max_verts - len(verts))
        padded.append(row)

    return {
        "max_verts_per_subcell": max_verts,
        "padded_vertices": padded,
    }


def emit_all_tet_like(
    cell_type: str,
    tables_by_kind: Dict[str, Dict[str, List]],
    output_dir: Path,
    provenance: Optional[str] = None,
    vtk_ref: Optional[str] = None,
    vtk_header_path: Optional[str] = None,
) -> List[Path]:
    """Emit tables in tetrahedron-like format (fixed-width 2D arrays)."""
    written: List[Path] = []
    for kind, arrays in tables_by_kind.items():
        written.append(
            _emit_tet_like_header(
                cell_type,
                kind,
                arrays,
                output_dir,
                provenance=provenance,
                vtk_ref=vtk_ref,
                vtk_header_path=vtk_header_path,
            )
        )
    return written
